# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OfP8B_5ouqSU7yJIHGy-Qe8ElonFNv9v
"""

!pip install skyfield cartopy matplotlib numpy scipy

from skyfield.api import Topos, load, EarthSatellite
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import numpy as np
import math
from matplotlib.dates import date2num, num2date, DateFormatter
from datetime import datetime, timedelta
from scipy.interpolate import interp1d

# Load timescale and define TLE for RADFXSAT (FOX-1B)
ts = load.timescale()
tle_line1 = "1 43017U 17073F   23313.35485710  .00001552  00000+0  10234-3 0  9995"
tle_line2 = "2 43017  97.6646  47.6582 0226447  98.2282 263.6763 14.85276338329245"
radfxsat = EarthSatellite(tle_line1, tle_line2, "RADFXSAT (FOX-1B)", ts)

# Bremen coordinates
bremen = Topos(latitude_degrees=53.0793, longitude_degrees=8.8017)

# Step 1: Print TLE elements
print("TLE Elements for RADFXSAT (FOX-1B):")
print(tle_line1)
print(tle_line2)

# Step 2: Latitude and Longitude of sub-satellite point
print("\nSub-satellite Point for One Orbit:")
times = ts.utc(2022, 12, 10, 0, np.arange(0, 1440, 1))  # Full day at 1-minute intervals
subpoints = [radfxsat.at(time).subpoint() for time in times]
longitudes = [sp.longitude.degrees for sp in subpoints]
latitudes = [sp.latitude.degrees for sp in subpoints]

# Convert times for Matplotlib
times_mpl = date2num([time.utc_datetime() for time in times])

# Plot the ground track
fig = plt.figure(figsize=(12, 6))
ax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())
ax.set_global()
ax.coastlines()
ax.stock_img()  # Use a real-world map background
ax.plot(longitudes, latitudes, label='Ground track', color='green', linewidth=1)
ax.plot(bremen.longitude.degrees, bremen.latitude.degrees, 'bo', label='Bremen')  # Mark Bremen
plt.title("Ground Track of RADFXSAT (FOX-1B) for One Day")
plt.legend()
plt.show()

# Step 3: Find a time slot where satellite is visible above Bremen (>30° altitude)
difference = radfxsat - bremen
altitudes = difference.at(times).altaz()[0]
azimuths = difference.at(times).altaz()[1]
visibility_intervals = []
current_interval = []

for time, alt in zip(times, altitudes.degrees):
    if alt > 30:
        if not current_interval:
            current_interval.append(time)
    else:
        if current_interval:
            current_interval.append(time)
            visibility_intervals.append(tuple(current_interval))
            current_interval = []

if visibility_intervals:
    print("\nSightings in Bremen:")
    for interval in visibility_intervals:
        rise_time = interval[0].utc_iso()
        set_time = interval[1].utc_iso()
        mid_time = interval[0].utc_datetime() + (interval[1].utc_datetime() - interval[0].utc_datetime()) / 2
        max_elevation = max([difference.at(ts.utc(dt.year, dt.month, dt.day, dt.hour, dt.minute, int(dt.second))).altaz()[0].degrees for dt in [interval[0].utc_datetime() + timedelta(seconds=i * 10) for i in range(int((interval[1].utc_datetime() - interval[0].utc_datetime()).total_seconds() // 10))]])
        print(f"{rise_time} rise above 30°")
        print(f"{mid_time.isoformat()} culminate")
        print(f"{set_time} set below 30°")
else:
    print("\nNo visibility above Bremen at >30° altitude found.")

# Adjust visibility intervals for 10° elevation threshold
visibility_intervals_10deg = []
current_interval_10deg = []

for time, alt in zip(times, altitudes.degrees):
    if alt > 10:
        if not current_interval_10deg:
            current_interval_10deg.append(time)
    else:
        if current_interval_10deg:
            current_interval_10deg.append(time)
            visibility_intervals_10deg.append(tuple(current_interval_10deg))
            current_interval_10deg = []

# Display connection times for 10° threshold
if visibility_intervals_10deg:
    print("\nConnection Times (Tcon) for 10° Elevation Threshold:")
    for interval in visibility_intervals_10deg:
        tcon_seconds = (interval[1].utc_datetime() - interval[0].utc_datetime()).total_seconds()
        tcon_minutes = tcon_seconds / 60
        print(f"Connection Time: {tcon_minutes:.2f} minutes ({tcon_seconds:.2f} seconds) from {interval[0].utc_iso()} to {interval[1].utc_iso()}")

    # Focus on the first interval for visualization
    time_window_start_10deg = visibility_intervals_10deg[0][0]
    time_window_end_10deg = visibility_intervals_10deg[0][1]
    fine_times_10deg = [time_window_start_10deg.utc_datetime() + timedelta(seconds=i * 10) for i in range(int((time_window_end_10deg.utc_datetime() - time_window_start_10deg.utc_datetime()).total_seconds() // 10) + 1)]
    ground_track_lat_10deg = [radfxsat.at(ts.utc(fine_time.year, fine_time.month, fine_time.day, fine_time.hour, fine_time.minute, fine_time.second)).subpoint().latitude.degrees for fine_time in fine_times_10deg]
    ground_track_lon_10deg = [radfxsat.at(ts.utc(fine_time.year, fine_time.month, fine_time.day, fine_time.hour, fine_time.minute, fine_time.second)).subpoint().longitude.degrees for fine_time in fine_times_10deg]

    # Plot ground track for connection period
    fig = plt.figure(figsize=(12, 6))
    ax = fig.add_subplot(1, 1, 1, projection=ccrs.PlateCarree())
    ax.coastlines()
    ax.add_feature(cfeature.BORDERS, linestyle=':')
    ax.plot(ground_track_lon_10deg, ground_track_lat_10deg, color='blue', label='Connection Track')
    ax.scatter([bremen.longitude.degrees], [bremen.latitude.degrees], color='red', label='Bremen')
    ax.set_title(f"Ground Track During Connection (10° Elevation)\n{time_window_start_10deg.utc_iso()} to {time_window_end_10deg.utc_iso()}")
    plt.legend()
    plt.show()
else:
    print("\nNo visibility above Bremen at >10° elevation found.")

# Debug: Check min and max altitudes
print("Minimum elevation:", min(altitudes.degrees))
print("Maximum elevation:", max(altitudes.degrees))

# Step 4: Focused plot for visibility period
if visibility_intervals:
    time_window_start = visibility_intervals[0][0]
    time_window_end = visibility_intervals[0][1]
    fine_times = [time_window_start.utc_datetime() + timedelta(seconds=i * 10) for i in range(int((time_window_end.utc_datetime() - time_window_start.utc_datetime()).total_seconds() // 10) + 1)]
    altitudes_fine = [difference.at(ts.utc(fine_time.year, fine_time.month, fine_time.day, fine_time.hour, fine_time.minute, fine_time.second)).altaz()[0].degrees for fine_time in fine_times]
    azimuths_fine = [difference.at(ts.utc(fine_time.year, fine_time.month, fine_time.day, fine_time.hour, fine_time.minute, fine_time.second)).altaz()[1].degrees for fine_time in fine_times]

  # Plot elevation and azimuth separately
fig, axs = plt.subplots(2, 1, figsize=(14, 8), sharex=True)

# Elevation Plot
axs[0].plot(fine_times, altitudes_fine, color="blue")
axs[0].axhline(30, color="red", linestyle="--", label="30° Threshold")
axs[0].set_title(f"Azimuth and Elevation:\nfor the interval {time_window_start.utc_iso()} to {time_window_end.utc_iso()}")
axs[0].set_ylabel("Elevation (°)")
axs[0].grid(True)
axs[0].legend()

# Azimuth Plot
axs[1].plot(fine_times, azimuths_fine, color="green")
axs[1].set_ylabel("Azimuth (°)")
axs[1].set_xlabel("Time (UTC)")
axs[1].grid(True)

# Format x-axis for both plots
axs[1].xaxis.set_major_formatter(DateFormatter('%H:%M:%S'))

plt.tight_layout()
plt.show()

# Step 6: Distance of the satellite to the ground station as a function of time
distances = [difference.at(time).distance().km for time in times]  # Calculate distance in km

# Plot the distance as a function of time
fig, ax = plt.subplots(figsize=(12, 6))
ax.plot(times_mpl, distances, color="purple", label="Distance to Ground Station")
ax.set_title("Distance of RADFXSAT (FOX-1B) to Bremen Over Time")
ax.set_xlabel("Time (UTC)")
ax.set_ylabel("Distance (km)")
ax.grid(True)
ax.legend()

# Format x-axis for time
ax.xaxis.set_major_formatter(DateFormatter('%H:%M:%S'))

plt.tight_layout()
plt.show()

# Step 5: Doppler frequency shift calculation
# Constants
G = 6.674 * 10**(-11)  # Gravitational constant in Nm^2/kg^2
M_earth = 5.972 * 10**24  # Mass of the Earth in kg
R_earth = 6.371 * 10**6  # Earth's radius in meters
c = 3 * 10**8  # Speed of light in m/s
transmit_frequency = 145.800 * 10**6  # Transmit frequency in Hz for RADFXSAT

# Find maximum altitude during visibility
if visibility_intervals:
    altitudes_for_high_times = [
        difference.at(ts.utc(dt.year, dt.month, dt.day, dt.hour, dt.minute, int(dt.second))).altaz()[0].degrees
        for interval in visibility_intervals
        for dt in [interval[0].utc_datetime() + timedelta(seconds=i * 10) for i in range(int((interval[1].utc_datetime() - interval[0].utc_datetime()).total_seconds() // 10))]
    ]
    altitude_max = max(altitudes_for_high_times) * 10**3  # Convert from km to meters
    R = R_earth + altitude_max

    # Calculate orbital velocity
    vs = math.sqrt((G * M_earth) / R)
    fd = (vs / c) * transmit_frequency

    print(f"\nDoppler Frequency Shift: {fd:.2f} Hz")

# Circular Doppler Shift Plot (Azimuth vs Doppler Shift)
doppler_shifts = [
    (radfxsat.at(ts.utc(fine_time.year, fine_time.month, fine_time.day, fine_time.hour, fine_time.minute, fine_time.second)).velocity.km_per_s[2] / c) * transmit_frequency
    for fine_time in fine_times
]
azimuths_radians = np.radians(azimuths_fine)

fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(111, polar=True)
ax.plot(azimuths_radians, doppler_shifts, color="green", linewidth=1.5)  # Continuous line plot for circular Doppler
ax.set_theta_zero_location("N")
ax.set_theta_direction(-1)
ax.set_title("Circular Plot: Doppler Shift vs Azimuth")
plt.show()



